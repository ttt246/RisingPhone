package com.matthaigh27.chatgptwrapper.utils

import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.net.Uri
import android.os.Environment
import com.matthaigh27.chatgptwrapper.MyApplication
import com.matthaigh27.chatgptwrapper.models.common.HelpCommandModel
import com.matthaigh27.chatgptwrapper.models.common.HelpPromptModel
import com.matthaigh27.chatgptwrapper.utils.Constants.*
import org.json.JSONArray
import org.json.JSONException
import org.json.JSONObject
import java.io.ByteArrayOutputStream
import java.io.File
import java.io.FileInputStream
import java.io.FileNotFoundException
import java.io.IOException
import java.io.InputStream
import java.net.HttpURLConnection
import java.net.URL
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale

class Utils {
    /**
     * set bitmap from download url generated by firebase store
     *
     * @param src download url of image
     * @return bitmap of the image
     */
    fun getBitmapFromURL(src: String?): Bitmap? {
        return try {
            val url = URL(src)
            val connection: HttpURLConnection = url.openConnection() as HttpURLConnection
            connection.doInput = true
            connection.connect()
            val input: InputStream = connection.inputStream
            BitmapFactory.decodeStream(input)
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }

    /**
     * @param uri uri for converting to ByteArray
     * @return ByteArray data converted from image uri
     */
    fun convertImageToByte(uri: Uri?): ByteArray? {
        var data: ByteArray? = null
        try {
            val cr = MyApplication.appContext.contentResolver
            val inputStream: InputStream? = cr.openInputStream(uri!!)
            val bitmap = BitmapFactory.decodeStream(inputStream)
            val baos = ByteArrayOutputStream()
            bitmap.compress(Bitmap.CompressFormat.JPEG, 100, baos)
            data = baos.toByteArray()
        } catch (e: FileNotFoundException) {
            e.printStackTrace()
        }
        return data
    }

    /**
     * @param path local path for converting to ByteArray
     * @return ByteArray data converted from image local path
     */
    fun getBytesFromPath(path: String?): ByteArray? {
        try {
            val stream = FileInputStream(path)
            val byteArray = stream.readBytes()
            stream.close()
            return byteArray
        } catch (e: IOException) {
            e.printStackTrace()
        }
        return null
    }

    /**
     * this creats image file with current datetime captured by camera
     */
    fun createSDCardFile(): File {
        val timeStamp: String =
            SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(Date())
        val imageFileName = "IMG_" + timeStamp + "_"
        val storageDir: File =
            MyApplication.appContext.getExternalFilesDir(Environment.DIRECTORY_PICTURES)!!
        return File.createTempFile(
            imageFileName,  /* prefix */
            ".jpg",         /* suffix */
            storageDir      /* directory */
        )
    }

    /**
     * when users input command starting with '/'
     *
     * @param strCommand is string with '/' and '-', ex: /browser -d
     * @return command model with main ommand and assistance command
     */
    fun getHelpCommandFromStr(strCommand: String): HelpCommandModel {
        val commandModel = HelpCommandModel()
        if (strCommand == "/$HELP_COMMAND") {
            commandModel.mainCommandName = HELP_COMMAND
            commandModel.assistCommandName = HELP_COMMAND_ALL
            return commandModel
        }
        try {
            if (strCommand.startsWith("/$HELP_COMMAND") || strCommand.startsWith("!$HELP_COMMAND")) {
                val words = strCommand.split("\\s".toRegex()).toTypedArray()
                if (words.size != 2) {
                    throw Exception(HELP_COMMAND_ERROR_NO_MAIN)
                }
                commandModel.mainCommandName = words[0].substring(1, words[0].length)
                commandModel.assistCommandName = words[1]
                if (commandModel.mainCommandName == "" || commandModel.assistCommandName == "") {
                    throw Exception(HELP_COMMAND_ERROR_NO_MAIN)
                }
            } else {
                commandModel.mainCommandName = strCommand.substring(1, strCommand.length)
            }
        } catch (e: Exception) {
            throw Exception(HELP_COMMAND_ERROR_NO_INVALID_FORMAT)
        }
        return commandModel
    }

    fun getHelpCommandListFromJsonString(jsonStrCommandList: String): ArrayList<HelpPromptModel> {
        val commandlist = ArrayList<HelpPromptModel>()
        try {
            val helpCommandStrList = JSONArray(jsonStrCommandList)
            for (i in 0 until helpCommandStrList.length()) {
                val helpCommand = JSONObject(helpCommandStrList[i].toString())

                val helpPromptModel = HelpPromptModel()
                helpPromptModel.name = helpCommand.getString("name")
                helpPromptModel.description = helpCommand.getString("description")
                helpPromptModel.prompt = helpCommand.getString("prompt")

                helpPromptModel.tags = ArrayList()
                val jsonArrayTags = helpCommand.getJSONArray("tags")
                for (j in 0 until jsonArrayTags.length()) {
                    helpPromptModel.tags!!.add(jsonArrayTags[j].toString())
                }
                commandlist.add(helpPromptModel)
            }
        } catch (e: JSONException) {
            e.printStackTrace()
            throw Exception(ERROR_MSG_JSON)
        }
        return commandlist
    }

    companion object {
        var instance: Utils = Utils()
    }
}